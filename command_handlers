
//void handle_start(int fdudp, struct addrinfo *resudp, char *plid, int max_playtime);
//void handle_try(int fdudp, struct addrinfo *resudp, char *guess);
//void handle_show_trials(int fdtcp, struct addrinfo *restcp);
//void handle_scoreboard(int fdtcp, struct addrinfo *restcp);
//void handle_quit(int fdudp, struct addrinfo *resudp, char *plid);
//void handle_exit(int fdudp, struct addrinfo *resudp, char *plid);
//void handle_debug(int fdudp, struct addrinfo *resudp, char *plid, int max_playtime, char *key);

/**
   the Player application sends a message to the GS, using the UDP protocol, asking to start a 
   new game, provides the player identification PLID and indicates the max_playtime  value,  
   in seconds, in which the player proposes to complete the game (it cannot exceed 600 seconds).  
   The GS randomly selects a 4 colour key: C1 C2 C3 C4 and informs the player that it can start playing. 
   The Player application displays this information.
 */
void handle_start(int fdudp, struct addrinfo *resudp, char *plid, int max_playtime) {
    char message[256];
    char buffer[256];

    if (max_playtime > 600) {
        printf("Error: max_playtime cannot exceed 600 seconds.\n");
        return;
    }

    // Format the START request message
    snprintf(message, sizeof(message), "START %s %d\n", plid, max_playtime);
    
    if (send_udp(fdudp, message, resudp, buffer) == -1) {
        printf("Error: Failed to send START command\n");
    } else {
        printf("Server response: %s\n", buffer);
    }

    // Check the response from the Game Server
    if (strncmp(buffer, "OK", 2) == 0) {
        // The response starts with "OK", followed by the generated secret key
        printf("Game started successfully!\n");
        printf("Secret key: %s\n", buffer + 3);  // Display the secret key (skips "OK ")
    } else {
        // If the response is not "OK", display the error message
        printf("Server response: %s\n", buffer);
    }
}

/**
   the Player application sends a message to the GS, using the UDP protocol, 
   asks to check if C1 C2 C3 C4 is the secret key to be guessed. If the maximum number 
   of trials has been exceeded the player loses the game, otherwise the number of  
   trials is increased. If the maximum playtime (max_playtime) has been reached the player loses the game.   
   Otherwise, the GS replies informing the number of Ci guesses that are correct in 
   both colour and position (nB), and the number of Ci guesses that belong to the 
   secret key but are incorrectly positioned (nW). If nB = 4 the secret code has 
   been correctly guessed and the player wins the game. The Player application displays the received information.
 */
void handle_try(int fdudp, struct addrinfo *resudp, char *guess) {
    char message[256];
    char buffer[256];

    // Format the TRY request message
    snprintf(message, sizeof(message), "TRY %s\n", guess);

    // Check the response from the Game Server
    if (send_udp(fdudp, message, resudp, buffer) == -1) {
        printf("Error: Failed to send TRY command\n");
    } else {
        printf("Server response: %s\n", buffer);
    }
}

/**
 * the Player establishes a TCP session with the GS and sends a message asking to receive a list of 
 * previously made trials and the respective results. In reply, the GS sends a text 
 * file containing the requested list (including a line for each trial: C1 C2 C3 C4 nB nW) 
 * and the remaining playing time. After receiving the reply from the GS, 
 * the  list  of  trials  and  the  corresponding  results is  displayed  by  the  Player application
 */
void handle_show_trials(int fdtcp, struct addrinfo *restcp) {
    char message[] = "SHOW_TRIALS\n";
    char buffer[1024];

    if (send_tcp(fdtcp, message, restcp, buffer) == -1) {
        printf("Error: Failed to fetch trials\n");
    } else {
        printf("Trials:\n%s\n", buffer);
    }
}